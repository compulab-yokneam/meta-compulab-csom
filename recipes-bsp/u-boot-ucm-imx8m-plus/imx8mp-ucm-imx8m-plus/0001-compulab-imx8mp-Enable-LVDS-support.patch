From da046f7ede77543be69876df98eb9e96d89206eb Mon Sep 17 00:00:00 2001
From: Valentin Raevsky <valentin@compulab.co.il>
Date: Fri, 20 Jan 2023 20:06:36 +0200
Subject: [PATCH] compulab: imx8mp: Enable LVDS support

Signed-off-by: Valentin Raevsky <valentin@compulab.co.il>
---
 arch/arm/dts/compulab-imx8mp-binman.dtsi      | 137 +++++++++
 arch/arm/dts/imx8mp-lcdif2.dtsi               | 109 +++++++
 arch/arm/dts/imx8mp-lcdif3.dtsi               | 195 ++++++++++++
 arch/arm/dts/imx8mp.dtsi                      |   3 +
 arch/arm/dts/ucm-imx8m-plus-lcdif3.dtsi       |  73 +++++
 arch/arm/dts/ucm-imx8m-plus-u-boot.dtsi       |  46 ++-
 arch/arm/dts/ucm-imx8m-plus.dts               | 118 +++++++-
 arch/arm/mach-imx/imx8m/clock_imx8mm.c        |  59 +++-
 board/compulab/common/Makefile                |   4 +
 board/compulab/common/fake_backlight.c        |  55 ++++
 configs/ucm-imx8m-plus_defconfig              |   2 +
 configs/ucm-imx8m-plus_lvds_defconfig         | 187 ++++++++++++
 drivers/clk/clk-uclass.c                      |  44 +++
 drivers/reset/Kconfig                         |   5 +
 drivers/reset/Makefile                        |   1 +
 drivers/reset/reset-imx-hdmimix.c             | 139 +++++++++
 drivers/reset/reset-uclass.c                  |  27 +-
 drivers/video/nxp/imx/Kconfig                 |   9 +
 drivers/video/nxp/imx/Makefile                |   1 +
 drivers/video/nxp/imx/imx8mp_lvds.c           | 281 ++++++++++++++++++
 drivers/video/nxp/imx/imx_lcdifv3.c           | 206 ++++++++++++-
 include/dt-bindings/clock/imx8mp-clock1.h     |  50 ++++
 include/dt-bindings/reset/imx-hdmimix-reset.h |  21 ++
 23 files changed, 1730 insertions(+), 42 deletions(-)
 create mode 100644 arch/arm/dts/compulab-imx8mp-binman.dtsi
 create mode 100644 arch/arm/dts/imx8mp-lcdif2.dtsi
 create mode 100644 arch/arm/dts/imx8mp-lcdif3.dtsi
 create mode 100644 arch/arm/dts/ucm-imx8m-plus-lcdif3.dtsi
 create mode 100644 board/compulab/common/fake_backlight.c
 create mode 100644 configs/ucm-imx8m-plus_lvds_defconfig
 create mode 100644 drivers/reset/reset-imx-hdmimix.c
 create mode 100644 drivers/video/nxp/imx/imx8mp_lvds.c
 create mode 100644 include/dt-bindings/clock/imx8mp-clock1.h
 create mode 100644 include/dt-bindings/reset/imx-hdmimix-reset.h

diff --git a/arch/arm/dts/compulab-imx8mp-binman.dtsi b/arch/arm/dts/compulab-imx8mp-binman.dtsi
new file mode 100644
index 0000000000..0e30449a61
--- /dev/null
+++ b/arch/arm/dts/compulab-imx8mp-binman.dtsi
@@ -0,0 +1,137 @@
+/ {
+	binman: binman {
+		multiple-images;
+	};
+};
+
+&binman {
+	 u-boot-spl-ddr {
+		filename = "u-boot-spl-ddr.bin";
+		pad-byte = <0xff>;
+		align-size = <4>;
+		align = <4>;
+
+		u-boot-spl {
+			align-end = <4>;
+		};
+
+		blob_1: blob-ext@1 {
+			filename = "board/compulab/plat/imx8mp/firmware/lpddr4_pmu_train_1d_imem_202006.bin.fw";
+			size = <0x8000>;
+		};
+
+		blob_2: blob-ext@2 {
+			filename = "board/compulab/plat/imx8mp/firmware/lpddr4_pmu_train_1d_dmem_202006.bin.fw";
+			size = <0x4000>;
+		};
+
+		blob_3: blob-ext@3 {
+			filename = "board/compulab/plat/imx8mp/firmware/lpddr4_pmu_train_2d_imem_202006.bin.fw";
+			size = <0x8000>;
+		};
+
+		blob_4: blob-ext@4 {
+			filename = "board/compulab/plat/imx8mp/firmware/lpddr4_pmu_train_2d_dmem_202006.bin.fw";
+			size = <0x4000>;
+		};
+	};
+
+	spl {
+		filename = "spl.bin";
+
+		mkimage {
+			args = "-n spl/u-boot-spl.cfgout -T imx8mimage -e 0x920000";
+
+			blob {
+				filename = "u-boot-spl-ddr.bin";
+			};
+		};
+	};
+
+	itb {
+		filename = "u-boot.itb";
+
+		fit {
+			description = "Configuration to load ATF before U-Boot";
+			#address-cells = <1>;
+			fit,external-offset = <CONFIG_FIT_EXTERNAL_OFFSET>;
+
+			images {
+				uboot {
+					description = "U-Boot (64-bit)";
+					type = "standalone";
+					arch = "arm64";
+					compression = "none";
+					load = <CONFIG_SYS_TEXT_BASE>;
+
+					uboot_blob: blob-ext {
+						filename = "u-boot-nodtb.bin";
+					};
+				};
+
+				atf {
+					description = "ARM Trusted Firmware";
+					type = "firmware";
+					arch = "arm64";
+					compression = "none";
+					load = <0x970000>;
+					entry = <0x970000>;
+
+					atf_blob: blob-ext {
+						filename = "board/compulab/plat/imx8mp/firmware/bl31.bin.fw";
+					};
+				};
+
+				optee {
+					description = "OP-TEE";
+					type = "firmware";
+					arch = "arm64";
+					os = "tee";
+					compression = "none";
+					load = <0x56000000>;
+					entry = <0x56000000>;
+
+					blob-ext {
+						filename = "board/compulab/plat/imx8mp/firmware/tee.bin.fw";
+					};
+				};
+
+				fdt {
+					description = "NAME";
+					type = "flat_dt";
+					compression = "none";
+
+					uboot_fdt_blob: blob-ext {
+						filename = "u-boot.dtb";
+					};
+				};
+			};
+
+			configurations {
+				default = "conf";
+
+				conf {
+					description = "NAME";
+					firmware = "uboot";
+					loadables = "atf" , "optee";
+					fdt = "fdt";
+				};
+			};
+		};
+	};
+
+	imx-boot {
+		filename = "flash.bin";
+		pad-byte = <0x00>;
+
+		spl: blob-ext@1 {
+			filename = "spl.bin";
+			offset = <0x0>;
+		};
+
+		uboot: blob-ext@2 {
+			filename = "u-boot.itb";
+			offset = <0x58000>;
+		};
+	};
+};
diff --git a/arch/arm/dts/imx8mp-lcdif2.dtsi b/arch/arm/dts/imx8mp-lcdif2.dtsi
new file mode 100644
index 0000000000..8cebb94981
--- /dev/null
+++ b/arch/arm/dts/imx8mp-lcdif2.dtsi
@@ -0,0 +1,109 @@
+/ {
+	ldb: ldb@32ec005c {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "fsl,imx8mp-ldb";
+		clocks = <&clk IMX8MP_CLK_MEDIA_LDB_ROOT>;
+		clock-names = "ldb";
+		assigned-clocks = <&clk IMX8MP_CLK_MEDIA_LDB>;
+		assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>;
+		gpr = <&mediamix_blk_ctl>;
+		power-domains = <&mediamix_pd>;
+		status = "disabled";
+
+		lvds-channel@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0>;
+			phys = <&ldb_phy1>;
+			phy-names = "ldb_phy";
+			status = "disabled";
+
+			port@0 {
+				reg = <0>;
+
+				ldb_ch0: endpoint {
+					remote-endpoint = <&lcdif2_disp_ldb_ch0>;
+				};
+			};
+		};
+
+		lvds-channel@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			phys = <&ldb_phy2>;
+			phy-names = "ldb_phy";
+			satus = "disabled";
+
+			port@0 {
+				reg = <0>;
+
+				ldb_ch1: endpoint {
+					remote-endpoint = <&lcdif2_disp_ldb_ch1>;
+				};
+			};
+		};
+	};
+
+	ldb_phy: phy@32ec0128 {
+		compatible = "fsl,imx8mp-lvds-phy";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		gpr = <&mediamix_blk_ctl>;
+		clocks = <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+		clock-names = "apb";
+		power-domains = <&mediamix_pd>;
+		status = "disabled";
+
+		ldb_phy1: port@0 {
+			reg = <0>;
+			#phy-cells = <0>;
+		};
+
+		ldb_phy2: port@1 {
+			reg = <1>;
+			#phy-cells = <0>;
+		};
+	};
+};
+
+&aips4 {
+	lcdif2: lcd-controller@32e90000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "fsl,imx8mp-lcdif2";
+		reg = <0x32e90000 0x10000>;
+		clocks = <&clk IMX8MP_CLK_MEDIA_DISP2_PIX_ROOT>,
+			 <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+			 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+		clock-names = "pix", "disp-axi", "disp-apb";
+		assigned-clocks = <&clk IMX8MP_CLK_MEDIA_DISP2_PIX>,
+				  <&clk IMX8MP_CLK_MEDIA_AXI>,
+				  <&clk IMX8MP_CLK_MEDIA_APB>;
+		assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>,
+					 <&clk IMX8MP_SYS_PLL2_1000M>,
+					 <&clk IMX8MP_SYS_PLL1_800M>;
+		assigned-clock-rates = <0>, <500000000>, <200000000>;
+		interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+		blk-ctl = <&mediamix_blk_ctl>;
+		power-domains = <&mediamix_pd>;
+		status = "disabled";
+
+		lcdif2_disp: port@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0>;
+
+			lcdif2_disp_ldb_ch0: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&ldb_ch0>;
+			};
+
+			lcdif2_disp_ldb_ch1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&ldb_ch1>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/imx8mp-lcdif3.dtsi b/arch/arm/dts/imx8mp-lcdif3.dtsi
new file mode 100644
index 0000000000..26530b2629
--- /dev/null
+++ b/arch/arm/dts/imx8mp-lcdif3.dtsi
@@ -0,0 +1,195 @@
+#include <dt-bindings/clock/imx8mp-clock1.h>
+#include <dt-bindings/reset/imx-hdmimix-reset.h>
+
+/{ 
+	aliases {
+		hdmi_hpd = &hdmi_hpd;
+	};
+};
+
+&aips4 {
+	/* TODO for HDMI PHY power on */
+	hdmi_blk: hdmi-blk@32fc0000 {
+		compatible = "syscon";
+		reg = <0x32fc0000 0x1000>;
+	};
+
+	hdmimix: hdmimix@32fc0000 {
+		compatible = "fsl,imx8mp-audiomix", "fsl,imx8mp-hdmimix";
+		reg = <0x32fc0000 0x1000>;
+	};
+
+	hdmimix_clk: clock-controller {
+		compatible = "fsl,imx8mp-hdmimix-clk", "syscon";
+		#clock-cells = <1>;
+		clocks = <&osc_24m>, <&hdmiphy_clk 0>;
+		clock-names = "osc_24m", "hdmi_phy";
+		reg = <0x32fc0000 0x1000>;
+		status = "disabled";
+	};
+
+	hdmimix_reset: reset-controller {
+		compatible = "fsl,imx8mp-hdmimix-reset";
+		reg = <0x32fc0000 0x1000>;
+		#reset-cells = <1>;
+		status = "disabled";
+	};
+
+	irqsteer_hdmi: irqsteer@32fc2000 {
+		compatible = "fsl,imx-irqsteer";
+		reg = <0x32fc2000 0x1000>;
+		interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-controller;
+		interrupt-parent = <&gic>;
+		#interrupt-cells = <1>;
+		fsl,channel = <1>;
+		fsl,num-irqs = <64>;
+		clocks = <&hdmimix_clk IMX8MP_CLK_HDMIMIX_IRQS_STEER_CLK>;
+		clock-names = "ipg";
+		assigned-clocks = <&clk IMX8MP_CLK_HDMI_APB>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_133M>;
+		assigned-clock-rates = <133000000>;
+		resets = <&hdmimix_reset IMX_HDMIMIX_IRQ_STEER_RESET>;
+		power-domains = <&hdmimix_pd>;
+		status = "disabled";
+	};
+
+	hdmi_pavi: hdmi-pai-pvi@32fc4000 {
+		#phy-cells = <1>;
+		compatible = "fsl,imx8mp-hdmi-pavi";
+		reg = <0x32fc4000 0x1000>;
+		clocks = <&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_VID_LINK_PIX_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_GPA_CLK>;
+		clock-names = "pvi_clk", "pai_clk";
+		resets = <&hdmimix_reset IMX_HDMIMIX_HDMI_PAI_RESET>,
+				<&hdmimix_reset IMX_HDMIMIX_HDMI_PVI_RESET>;
+		reset-names = "pai_rst", "pvi_rst";
+		power-domains = <&hdmimix_pd>;
+		status = "disabled";
+	};
+
+	lcdif3: lcd-controller@32fc6000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "fsl,imx8mp-lcdif3";
+		reg = <0x32fc6000 0x10000>;
+		clocks = <&hdmiphy_clk 0>,
+				<&clk IMX8MP_CLK_HDMI_AXI>,
+				<&clk IMX8MP_CLK_HDMI_APB>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_APB_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_B_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_XTAL24M_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_TX_PIX_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_APB_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_B_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_PDI_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_PIX_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_SPU_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_NOC_HDMI_CLK>;
+		clock-names = "pix", "disp-axi", "disp-apb",
+					"mix_apb","mix_axi", "xtl_24m", "mix_pix", "lcdif_apb",
+					"lcdif_axi", "lcdif_pdi", "lcdif_pix", "lcdif_spu",
+					"noc_hdmi";
+		assigned-clocks =  <&clk IMX8MP_CLK_HDMI_AXI>,
+						<&clk IMX8MP_CLK_HDMI_APB>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+					 <&clk IMX8MP_SYS_PLL1_133M>;
+		assigned-clock-rates = <500000000>, <133000000>;
+		interrupts = <8 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&irqsteer_hdmi>;
+		resets = <&hdmimix_reset IMX_HDMIMIX_LCDIF_RESET>;
+		power-domains = <&hdmimix_pd>;
+		status = "disabled";
+
+		lcdif3_disp: port@0 {
+			reg = <0>;
+
+			lcdif3_to_hdmi: endpoint {
+				remote-endpoint = <&hdmi_from_lcdif3>;
+			};
+		};
+	};
+
+	hdmi: hdmi@32fd8000 {
+		compatible = "fsl,imx8mp-hdmi";
+		reg = <0x32fd8000 0x7eff>;
+		interrupts = <0 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&irqsteer_hdmi>;
+		clocks = <&clk IMX8MP_CLK_HDMI_APB>,
+				<&clk IMX8MP_CLK_HDMI_24M>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PHY_INT_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PREP_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_SKP_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_SFR_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PIXEL_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_CEC_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_APB_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_HPI_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_FDCC_REF_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PIPE_CLK_SEL>;
+		clock-names = "iahb", "isfr", "phy_int", "prep_clk", "skp_clk", "sfr_clk", "pix_clk",
+						"cec_clk", "apb_clk", "hpi_clk", "fdcc_ref", "pipe_clk";
+		assigned-clocks = <&clk IMX8MP_CLK_HDMI_APB>,
+					<&clk IMX8MP_CLK_HDMI_AXI>,
+					<&clk IMX8MP_CLK_HDMI_24M>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_133M>,
+					<&clk IMX8MP_SYS_PLL2_500M>,
+					<&clk IMX8MP_CLK_24M>;
+		assigned-clock-rates = <133000000>, <500000000>, <24000000>;
+		ddc-i2c-bus = <&hdmi_i2c>;
+		phys = <&hdmiphy>, <&hdmi_pavi 0>, <&hdmi_pavi 1>, <&hdmi_pavi 2>;
+		phy-names = "hdmi", "pavi", "pvi", "pai";
+		resets = <&hdmimix_reset IMX_HDMIMIX_HDMI_TX_RESET>;
+		gpr = <&hdmimix_clk>;
+		power-domains = <&hdmi_phy_pd>;
+		status = "disabled";
+
+		port@0 {
+			hdmi_from_lcdif3: endpoint {
+				remote-endpoint = <&lcdif3_to_hdmi>;
+			};
+		};
+	};
+
+	hdmi_i2c: hdmi-i2c@32fd8000 {
+		compatible = "fsl,imx8mp-hdmi-i2c";
+		reg = <0x32fd8000 0x7eff>;
+	};
+
+	hdmi_hpd: hdmi-hpd@32fdb000 {
+		compatible = "fsl,imx8mp-hdmi-hpd";
+		reg = <0x32fdb000 0x1000>;
+		power-domains = <&hdmi_phy_pd>;
+		status = "disabled";
+	};
+
+	hdmiphy: hdmiphy@32fdff00 {
+		compatible = "fsl,samsung-hdmi-phy";
+		clocks = <&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PHY_APB_CLK>,
+				<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PHY_INT_CLK>,
+				<&hdmiphy_clk 0>;
+		clock-names = "apb", "ref", "hdmi_phy";
+		#phy-cells = <0>;
+		resets = <&hdmimix_reset IMX_HDMIMIX_HDMI_PHY_RESET>;
+		power-domains = <&hdmi_phy_pd>;
+		status = "disabled";
+	};
+
+	hdmiphy_clk: hdmi-phy-clk@32fdff00 {
+		#clock-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x32fdff00 0x100>;
+		compatible = "fsl,samsung-hdmi-phy-clk";
+		clocks = <&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PHY_INT_CLK>;
+		clock-names = "parent";
+		clock-output-names = "hdmi_phy";
+		status = "disabled";
+	};
+
+	dummy: dummy {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <0>;
+		clock-output-names = "dummy";
+	};
+};
diff --git a/arch/arm/dts/imx8mp.dtsi b/arch/arm/dts/imx8mp.dtsi
index 015f40db86..ebcf006630 100644
--- a/arch/arm/dts/imx8mp.dtsi
+++ b/arch/arm/dts/imx8mp.dtsi
@@ -1254,3 +1254,6 @@
 		status = "disabled";
 	};
 };
+
+#include "imx8mp-lcdif2.dtsi"
+#include "imx8mp-lcdif3.dtsi"
diff --git a/arch/arm/dts/ucm-imx8m-plus-lcdif3.dtsi b/arch/arm/dts/ucm-imx8m-plus-lcdif3.dtsi
new file mode 100644
index 0000000000..bc51e36ccb
--- /dev/null
+++ b/arch/arm/dts/ucm-imx8m-plus-lcdif3.dtsi
@@ -0,0 +1,73 @@
+/ {
+	aliases {
+		t_hdmi = &t_hdmi;
+	};
+
+};
+
+&hdmi_phy_pd {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&hdmimix_pd {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&hdmi {
+    	u-boot,dm-spl;
+	status = "okay";
+	display-timings {
+		t_hdmi: t-hdmi-default {
+			/* m101nwwb by default */
+			clock-frequency = <148500000>;
+			hactive = <1920>;
+			vactive = <1080>;
+			hback-porch = <148>;
+			hfront-porch = <88>;
+			vback-porch = <36>;
+			vfront-porch = <4>;
+			hsync-len = <44>;
+			vsync-len = <5>;
+			hsync-active = <1>;
+			vsync-active = <1>;
+			de-active = <1>;
+		};
+	};
+};
+
+&hdmimix_clk {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&hdmimix_reset {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&hdmi_hpd {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&hdmiphy {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&hdmiphy_clk {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&hdmi_pavi {
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&lcdif3 {
+	u-boot,dm-spl;
+	status = "okay";
+};
diff --git a/arch/arm/dts/ucm-imx8m-plus-u-boot.dtsi b/arch/arm/dts/ucm-imx8m-plus-u-boot.dtsi
index 9186cbe4df..d5b9b64144 100644
--- a/arch/arm/dts/ucm-imx8m-plus-u-boot.dtsi
+++ b/arch/arm/dts/ucm-imx8m-plus-u-boot.dtsi
@@ -4,6 +4,8 @@
  * Copyright 2021 CompuLab
  */
 
+#include "compulab-imx8mp-binman.dtsi"
+
 / {
 	wdt-reboot {
 		compatible = "wdt-reboot";
@@ -84,10 +86,6 @@
 	u-boot,dm-spl;
 };
 
-&pinctrl_gpio4_20_hog {
-	u-boot,dm-spl;
-};
-
 &gpio1 {
 	u-boot,dm-spl;
 };
@@ -174,6 +172,14 @@
 	u-boot,dm-spl;
 };
 
+&pinctrl_pwm2 {
+	u-boot,dm-spl;
+};
+
+&pca9555 {
+	u-boot,dm-spl;
+};
+
 &eqos {
 	compatible = "fsl,imx-eqos";
 	/delete-property/ assigned-clocks;
@@ -188,12 +194,44 @@
 };
 
 &lcdif1 {
+    u-boot,dm-spl;
 	/delete-property/ assigned-clocks;
 	/delete-property/ assigned-clock-parents;
 	/delete-property/ assigned-clock-rates;
 };
 
+&lcdif2 {
+    u-boot,dm-spl;
+    /delete-property/ assigned-clocks;
+    /delete-property/ assigned-clock-parents;
+    /delete-property/ assigned-clock-rates;
+};
+
+&ldb {
+    u-boot,dm-spl;
+    /delete-property/ assigned-clocks;
+    /delete-property/ assigned-clock-parents;
+    /delete-property/ assigned-clock-rates;
+};
+
+&ldb_phy {
+    u-boot,dm-spl;
+    /delete-property/ assigned-clocks;
+    /delete-property/ assigned-clock-parents;
+    /delete-property/ assigned-clock-rates;
+};
+
+&pwm2 {
+    u-boot,dm-spl;
+};
+
+&lvds_backlight {
+	compatible = "clab,fake-backlight";
+    u-boot,dm-spl;
+};
+
 &mipi_dsi {
+    u-boot,dm-spl;
 	/delete-property/ assigned-clocks;
 	/delete-property/ assigned-clock-parents;
 	/delete-property/ assigned-clock-rates;
diff --git a/arch/arm/dts/ucm-imx8m-plus.dts b/arch/arm/dts/ucm-imx8m-plus.dts
index d65a0fd7e3..7b58d85f67 100644
--- a/arch/arm/dts/ucm-imx8m-plus.dts
+++ b/arch/arm/dts/ucm-imx8m-plus.dts
@@ -21,6 +21,11 @@
 		stdout-path = &uart2;
 #endif
 	};
+	aliases {
+		video0 = &lcdif1;
+		video1 = &lcdif2;
+		video2 = &lcdif3;
+	};
 
 	memory@40000000 {
 		device_type = "memory";
@@ -67,13 +72,11 @@
 	
 	dsi_host: dsi-host {
 		compatible = "samsung,sec-mipi-dsi";
-		status = "okay";
+		status = "disabled";
 	};
 
-	backlight: backlight {
-		compatible = "pwm-backlight";
+	lvds_backlight: lvds_backlight {
 		pwms = <&pwm2 0 3000000 0>;
-
 		brightness-levels = <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
 					17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
 					33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
@@ -102,12 +105,69 @@
 		panel-height-mm = <115>;
 		status = "okay";
 
+		display-timings {
+			native-mode = <&timing1>;
+			timing1: timing1 {
+				clock-frequency = <62000000>;
+				hactive = <1280>;
+				vactive = <720>;
+				hfront-porch = <30>;
+				hback-porch = <10>;
+				hsync-len = <20>;
+				vback-porch = <20>;
+				vfront-porch = <10>;
+				vsync-len = <10>;
+			};
+		};
 		port {
 			ili9881c_from_dsim: endpoint {
 				remote-endpoint = <&ili9881c_to_dsim>;
 			};
 		};
 	};
+
+	lvds0_panel: lvds-panel {
+		compatible = "simple-panel";
+		power-supply = <&lvds_power_supply>;
+		enable-gpios = <&pca9555 6 GPIO_ACTIVE_HIGH>;
+		backlight = <&lvds_backlight>;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: timing0 {
+				clock-frequency = <51200000>;
+				hactive = <1024>;
+				vactive = <600>;
+				hfront-porch = <160>;
+				hback-porch = <160>;
+				hsync-len = <1>;
+				vback-porch = <12>;
+				vfront-porch = <23>;
+				vsync-len = <1>;
+
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		port {
+			panel_lvds_in: endpoint {
+				remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+
+	lvds_power_supply: lvds-power-supply {
+		compatible = "regulator-fixed";
+		regulator-name = "lvds-power-supply";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		regulator-always-on;
+	};
 };
 
 &eqos {
@@ -149,16 +209,6 @@
 	};
 };
 
-&gpio4 {
-	gpio4_20_hog {
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_gpio4_20_hog>;
-		gpio-hog;
-		gpios = <20 GPIO_ACTIVE_HIGH>;
-		output-high;
-	};
-};
-
 &i2c1 {
 	clock-frequency = <400000>;
 	pinctrl-names = "default", "gpio";
@@ -336,6 +386,34 @@
 	status = "okay";
 };
 
+&lcdif2 {
+	status = "okay";
+};
+
+&ldb {
+	status = "okay";
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		status = "okay";
+		port@1 {
+			reg = <1>;
+			lvds_out: endpoint {
+				remote-endpoint = <&panel_lvds_in>;
+			};
+		};
+	};
+};
+
+&ldb_phy {
+	status = "okay";
+
+};
+
+&dsi_host {
+	status = "okay";
+};
+
 &mipi_dsi {
 	status = "okay";
 	port@1 {
@@ -533,7 +611,7 @@
 		>;
 	};
 
-	pinctrl_gpio4_20_hog: gpio420hoggrp {
+	pinctrl_typec_mux: typec1muxgrp {
 		fsl,pins = <
 			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x16
 		>;
@@ -683,3 +761,13 @@
 &soc_crit0 {
     temperature = <155000>;
 };
+
+&lcdif1 {
+	status = "disabled";
+};
+
+&lcdif2 {
+	status = "okay";
+};
+
+#include "ucm-imx8m-plus-lcdif3.dtsi"
diff --git a/arch/arm/mach-imx/imx8m/clock_imx8mm.c b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
index a97498c162..ee1c306987 100644
--- a/arch/arm/mach-imx/imx8m/clock_imx8mm.c
+++ b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
@@ -48,6 +48,7 @@ int enable_i2c_clk(unsigned char enable, unsigned i2c_num)
 }
 
 static struct imx_int_pll_rate_table imx8mm_fracpll_tbl[] = {
+	PLL_1443X_RATE(1039500000U, 693, 4, 2, 0),
 	PLL_1443X_RATE(1000000000U, 250, 3, 1, 0),
 	PLL_1443X_RATE(800000000U, 200, 3, 1, 0),
 	PLL_1443X_RATE(750000000U, 250, 2, 2, 0),
@@ -73,7 +74,7 @@ static int fracpll_configure(enum pll_clocks pll, u32 freq)
 	}
 
 	if (i == ARRAY_SIZE(imx8mm_fracpll_tbl)) {
-		printf("No matched freq table %u\n", freq);
+		printf("%s: No matched freq table %u\n", __func__, freq);
 		return -EINVAL;
 	}
 
@@ -150,7 +151,7 @@ void dram_enable_bypass(ulong clk_val)
 	}
 
 	if (i == ARRAY_SIZE(imx8mm_dram_bypass_tbl)) {
-		printf("No matched freq table %lu\n", clk_val);
+		printf("%s: No matched freq table %lu\n", __func__, clk_val);
 		return;
 	}
 
@@ -246,9 +247,29 @@ int intpll_configure(enum pll_clocks pll, ulong freq)
 			INTPLL_PRE_DIV_VAL(3) | INTPLL_POST_DIV_VAL(1);
 		break;
 	case MHZ(1200):
-		/* 24 * 0xc8 / 2 / 2 ^ 1 */
+		/* 24 * 0x12c / 3 / 2 ^ 1 */
+		pll_div_ctl_val = INTPLL_MAIN_DIV_VAL(0x12c) |
+			INTPLL_PRE_DIV_VAL(3) | INTPLL_POST_DIV_VAL(1);
+		break;
+	case MHZ(1400):
+		/* 24 * 0x15e / 3 / 2 ^ 1 */
+		pll_div_ctl_val = INTPLL_MAIN_DIV_VAL(0x15e) |
+			INTPLL_PRE_DIV_VAL(3) | INTPLL_POST_DIV_VAL(1);
+		break;
+	case MHZ(1500):
+		/* 24 * 0x177 / 3 / 2 ^ 1 */
+		pll_div_ctl_val = INTPLL_MAIN_DIV_VAL(0x177) |
+			INTPLL_PRE_DIV_VAL(3) | INTPLL_POST_DIV_VAL(1);
+		break;
+	case MHZ(1600):
+		/* 24 * 0xc8 / 3 / 2 ^ 0 */
 		pll_div_ctl_val = INTPLL_MAIN_DIV_VAL(0xc8) |
-			INTPLL_PRE_DIV_VAL(2) | INTPLL_POST_DIV_VAL(1);
+			INTPLL_PRE_DIV_VAL(3) | INTPLL_POST_DIV_VAL(0);
+		break;
+	case MHZ(1800):
+		/* 24 * 0xe1 / 3 / 2 ^ 0 */
+		pll_div_ctl_val = INTPLL_MAIN_DIV_VAL(0xe1) |
+			INTPLL_PRE_DIV_VAL(3) | INTPLL_POST_DIV_VAL(0);
 		break;
 	case MHZ(2000):
 		/* 24 * 0xfa / 3 / 2 ^ 0 */
@@ -279,7 +300,7 @@ int intpll_configure(enum pll_clocks pll, ulong freq)
 	return 0;
 }
 
-#define VIDEO_PLL_RATE 594000000U
+#define VIDEO_PLL_RATE 1039500000U
 
 void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
 {
@@ -307,7 +328,7 @@ find:
 	debug("mxs_set_lcdclk, pre = %d, post = %d\n", pre, post);
 
 #ifdef CONFIG_IMX8MP
-	clock_set_target_val(MEDIA_DISP1_PIX_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(1) | CLK_ROOT_PRE_DIV(pre - 1) | CLK_ROOT_POST_DIV(post - 1));
+	clock_set_target_val(MEDIA_DISP2_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(1) | CLK_ROOT_PRE_DIV(pre - 1) | CLK_ROOT_POST_DIV(post - 1));
 #elif defined(CONFIG_IMX8MN)
 	clock_set_target_val(DISPLAY_PIXEL_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(1) | CLK_ROOT_PRE_DIV(pre - 1) | CLK_ROOT_POST_DIV(post - 1));
 #else
@@ -322,17 +343,17 @@ void enable_display_clk(unsigned char enable)
 	if (enable) {
 		clock_enable(CCGR_DISPMIX, false);
 
-		/* Set Video PLL to 594Mhz, p = 1, m = 99,  k = 0, s = 2 */
+		/* Set Video PLL to 1039.5Mhz for LVDS, p = 4, m = 693,  k = 0, s = 2 */
 		fracpll_configure(ANATOP_VIDEO_PLL, VIDEO_PLL_RATE);
 
-		/* 400Mhz */
-		clock_set_target_val(MEDIA_AXI_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(2) | CLK_ROOT_PRE_DIV(CLK_ROOT_PRE_DIV2));
+		/* 500Mhz */
+		clock_set_target_val(MEDIA_AXI_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(1) | CLK_ROOT_PRE_DIV(CLK_ROOT_PRE_DIV2));
 
 		/* 200Mhz */
 		clock_set_target_val(MEDIA_APB_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(2) |CLK_ROOT_PRE_DIV(CLK_ROOT_PRE_DIV4));
 
-		/* 27Mhz MIPI DPHY PLL ref from video PLL */
-		clock_set_target_val(MEDIA_MIPI_PHY1_REF_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(7) |CLK_ROOT_POST_DIV(CLK_ROOT_POST_DIV22));
+		/* 519.75Mhz LVDS PLL ref from video PLL */
+		clock_set_target_val(MEDIA_LDB_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(7) |CLK_ROOT_POST_DIV(CLK_ROOT_POST_DIV2));
 		clock_enable(CCGR_DISPMIX, true);
 	} else {
 		clock_enable(CCGR_DISPMIX, false);
@@ -368,6 +389,17 @@ void enable_display_clk(unsigned char enable)
 }
 #endif
 
+u32 get_dsi_phy_ref_clk(void)
+{
+#ifdef CONFIG_IMX8MP
+	return get_root_clk(MEDIA_MIPI_PHY1_REF_CLK_ROOT);
+#elif defined(CONFIG_IMX8MN)
+	return get_root_clk(DISPLAY_DSI_PHY_REF_CLK_ROOT);
+#else
+	return get_root_clk(MIPI_DSI_PHY_REF_CLK_ROOT);
+#endif
+}
+
 void init_uart_clk(u32 index)
 {
 	/*
@@ -527,6 +559,7 @@ int clock_init(void)
 
 #ifdef CONFIG_IMX8MP
 	/* 8MP ROM already set NOC to 800Mhz, only need to configure NOC_IO clk to 600Mhz */
+	/* 8MP ROM already set GIC to 400Mhz, system_pll1_800m with div = 2 */
 	clock_set_target_val(NOC_IO_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(2));
 #else
 	clock_set_target_val(NOC_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(2));
@@ -617,7 +650,7 @@ int set_clk_eqos(enum enet_freq type)
 	return 0;
 }
 
-int imx_eqos_txclk_set_rate(unsigned long rate)
+int imx_eqos_txclk_set_rate(ulong rate)
 {
 	u32 val;
 	u32 eqos_post_div;
@@ -883,7 +916,7 @@ static u32 decode_fracpll(enum clk_root_src frac_pll)
 		pll_fdiv_ctl1 = readl(&ana_pll->video_pll1_fdiv_ctl1);
 		break;
 	default:
-		printf("Not supported\n");
+		printf("Unsupported clk_root_src %d\n", frac_pll);
 		return 0;
 	}
 
diff --git a/board/compulab/common/Makefile b/board/compulab/common/Makefile
index b57f589ec2..7dfe91d32f 100644
--- a/board/compulab/common/Makefile
+++ b/board/compulab/common/Makefile
@@ -15,3 +15,7 @@ obj-y				+= eeprom.o
 endif # (CONFIG_SYS_I2C || CONFIG_DM_I2C2)
 obj-$(CONFIG_LCD)		+= omap3_display.o
 obj-$(CONFIG_SMC911X)		+= omap3_smc911x.o
+
+ifndef CONFIG_SPL_BUILD
+obj-y += fake_backlight.o
+endif
diff --git a/board/compulab/common/fake_backlight.c b/board/compulab/common/fake_backlight.c
new file mode 100644
index 0000000000..b77d43d806
--- /dev/null
+++ b/board/compulab/common/fake_backlight.c
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2016 Google, Inc
+ * Written by Simon Glass <sjg@chromium.org>
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <backlight.h>
+
+struct fake_backlight_priv {
+	bool enabled;
+};
+
+
+static int fake_backlight_enable(struct udevice *dev)
+{
+	return 0;
+}
+
+static int fake_backlight_set_brightness(struct udevice *dev, int percent)
+{
+	return 0;
+}
+
+
+static int fake_backlight_probe(struct udevice *dev)
+{
+	return 0;
+}
+
+static int fake_backlight_of_to_plat(struct udevice *dev)
+{
+	return 0;
+}
+
+static const struct backlight_ops fake_backlight_ops = {
+	.enable		= fake_backlight_enable,
+	.set_brightness	= fake_backlight_set_brightness,
+};
+
+static const struct udevice_id fake_backlight_ids[] = {
+	{ .compatible = "clab,fake-backlight" },
+	{ }
+};
+
+U_BOOT_DRIVER(fake_backlight) = {
+	.name	= "fake_backlight",
+	.id	= UCLASS_PANEL_BACKLIGHT,
+	.of_match = fake_backlight_ids,
+	.ops	= &fake_backlight_ops,
+	.of_to_plat	= fake_backlight_of_to_plat,
+	.probe		= fake_backlight_probe,
+	.priv_auto	= sizeof(struct fake_backlight_priv),
+};
diff --git a/configs/ucm-imx8m-plus_defconfig b/configs/ucm-imx8m-plus_defconfig
index 63591ffa8e..a5d0f26b2e 100644
--- a/configs/ucm-imx8m-plus_defconfig
+++ b/configs/ucm-imx8m-plus_defconfig
@@ -117,6 +117,7 @@ CONFIG_DM_REGULATOR=y
 CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_PWM=y
+CONFIG_DM_RESET=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_ABX80X=y
 CONFIG_MXC_UART=y
@@ -143,6 +144,7 @@ CONFIG_USB_ETHER_SMSC95XX=y
 CONFIG_DM_VIDEO=y
 CONFIG_SYS_WHITE_ON_BLACK=y
 CONFIG_VIDEO_LCD_STARTEK_ILI9881C=y
+CONFIG_VIDEO_IMX8MP_LVDS=y
 CONFIG_VIDEO_IMX_SEC_DSI=y
 CONFIG_VIDEO_IMX_LCDIFV3=y
 # CONFIG_WATCHDOG is not set
diff --git a/configs/ucm-imx8m-plus_lvds_defconfig b/configs/ucm-imx8m-plus_lvds_defconfig
new file mode 100644
index 0000000000..2d1d7d97f3
--- /dev/null
+++ b/configs/ucm-imx8m-plus_lvds_defconfig
@@ -0,0 +1,187 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SYS_MALLOC_LEN=0x2000000
+CONFIG_SYS_MALLOC_F_LEN=0x10000
+CONFIG_SPL_GPIO=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_NR_DRAM_BANKS=3
+CONFIG_SYS_MEMTEST_START=0x60000000
+CONFIG_SYS_MEMTEST_END=0xC0000000
+CONFIG_ENV_SIZE=0x4000
+CONFIG_ENV_OFFSET=0x3F0000
+CONFIG_DM_GPIO=y
+CONFIG_DEFAULT_DEVICE_TREE="ucm-imx8m-plus"
+CONFIG_SPL_TEXT_BASE=0x920000
+CONFIG_TARGET_UCM_IMX8M_PLUS=y
+CONFIG_SYS_I2C_EEPROM_BUS_SB=0x1
+CONFIG_SPL_SERIAL=y
+CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_SPL=y
+CONFIG_IMX_HAB=y
+CONFIG_FSL_MFGPROT=y
+CONFIG_SPL_IMX_ROMAPI_LOADADDR=0x48000000
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_SYS_LOAD_ADDR=0x40400000
+CONFIG_FIT=y
+CONFIG_FIT_EXTERNAL_OFFSET=0x3000
+CONFIG_FIT_SIGNATURE=y
+CONFIG_SPL_LOAD_FIT=y
+# CONFIG_USE_SPL_FIT_GENERATOR is not set
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_BOOTCOMMAND="run distro_bootcmd;run bsp_bootcmd"
+CONFIG_DEFAULT_FDT_FILE="ucm-imx8m-plus.dtb"
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_BOOTROM_SUPPORT=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SPL_I2C=y
+CONFIG_SPL_POWER=y
+CONFIG_SPL_WATCHDOG=y
+CONFIG_SYS_PROMPT="u-boot=> "
+# CONFIG_BOOTM_NETBSD is not set
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_ERASEENV=y
+CONFIG_CMD_NVEDIT_EFI=y
+# CONFIG_CMD_CRC32 is not set
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_OPTEE_RPMB=y
+CONFIG_CMD_POWEROFF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_WDT=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_RTC=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_GETTIME=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SPL_DM=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_SPL_CLK_COMPOSITE_CCF=y
+CONFIG_CLK_COMPOSITE_CCF=y
+CONFIG_SPL_CLK_IMX8MP=y
+CONFIG_CLK_IMX8MP=y
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x42800000
+CONFIG_FASTBOOT_BUF_SIZE=0x40000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_GPIO_HOG=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_SUPPORT_EMMC_RPMB=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_ES_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_FSL_USDHC=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0
+CONFIG_SF_DEFAULT_SPEED=40000000
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_DM_ETH_PHY=y
+CONFIG_PHY_GIGE=y
+CONFIG_DWC_ETH_QOS=y
+CONFIG_DWC_ETH_QOS_IMX=y
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_PHY=y
+CONFIG_PHY_IMX8MQ_USB=y
+CONFIG_PINCTRL=y
+CONFIG_SPL_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_POWER_DOMAIN=y
+CONFIG_IMX8M_POWER_DOMAIN=y
+CONFIG_DM_PMIC=y
+CONFIG_DM_PMIC_PCA9450=y
+CONFIG_SPL_DM_PMIC_PCA9450=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_PWM=y
+CONFIG_DM_RESET=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_ABX80X=y
+CONFIG_MXC_UART=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_NXP_FSPI=y
+CONFIG_SYSRESET=y
+CONFIG_SYSRESET_PSCI=y
+CONFIG_DM_THERMAL=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_DM_VIDEO=y
+CONFIG_VIDEO_LOGO=y
+CONFIG_SYS_WHITE_ON_BLACK=y
+CONFIG_VIDEO_LCD_STARTEK_ILI9881C=y
+CONFIG_VIDEO_IMX8MP_LVDS=y
+CONFIG_VIDEO_IMX_SEC_DSI=y
+CONFIG_VIDEO_IMX_LCDIFV3=y
+CONFIG_IMX8M_PM_DOMAINS=y
+CONFIG_SPLASH_SCREEN=y
+CONFIG_SPLASH_SCREEN_ALIGN=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+# CONFIG_WATCHDOG is not set
+# CONFIG_WATCHDOG_AUTOSTART is not set
+CONFIG_IMX_WATCHDOG=y
+CONFIG_WDT=y
+CONFIG_SPL_RSA=y
+CONFIG_SHA384=y
+CONFIG_LZO=y
+CONFIG_BZIP2=y
+# CONFIG_HEXDUMP is not set
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_EFI_VAR_BUF_SIZE=139264
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_RUNTIME_UPDATE_CAPSULE=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_IGNORE_OSINDICATIONS=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_CAPSULE_AUTHENTICATE=y
+CONFIG_EFI_SECURE_BOOT=y
diff --git a/drivers/clk/clk-uclass.c b/drivers/clk/clk-uclass.c
index b87288da7a..c7a664281d 100644
--- a/drivers/clk/clk-uclass.c
+++ b/drivers/clk/clk-uclass.c
@@ -794,6 +794,50 @@ void devm_clk_put(struct udevice *dev, struct clk *clk)
 	WARN_ON(rc);
 }
 
+int devm_clk_get_enable_bulk(struct udevice *dev, const char * const *names,
+		int cnt, int optional_mask, struct clk **clkp)
+{
+	struct clk *clk;
+	int ret;
+	int i = 0;
+
+	*clkp = NULL;
+	clk = devres_alloc(devm_clk_release, sizeof(struct clk) * cnt, __GFP_ZERO);
+	if (unlikely(!clk)) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	for (i = 0; i < cnt; i++, optional_mask >>= 1) {
+		ret = clk_get_by_name(dev, names[i], &clk[i]);
+		if (ret) {
+			debug("Unable to get %s clk: %d\n", names[i], ret);
+			if ((ret == -ENODATA) && (optional_mask & 1))
+				continue;
+			goto release;
+		}
+
+		ret = clk_prepare_enable(&clk[i]);
+		if (ret) {
+			debug("Cannot enable %s clock: %d\n", names[i], ret);
+			goto release;
+		}
+	}
+	devres_add(dev, clk);
+	*clkp = clk;
+	return 0;
+
+release:
+	while (i > 0) {
+		i--;
+		if (clk[i].dev) {
+			clk_disable_unprepare(&clk[i]);
+		}
+	}
+	devres_free(clk);
+	return ret;
+}
+
 int clk_uclass_post_probe(struct udevice *dev)
 {
 	/*
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index e89381a1e4..94b2b2da5d 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -204,4 +204,9 @@ config RESET_DISPMIX
 	default n
 	help
 	  Support for reset controller on i.MX8M SoCs.
+
+config RESET_IMX_HDMIMIX
+	bool
+	default y
+
 endmenu
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index b2dc98bfe5..b97bde62d3 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -30,3 +30,4 @@ obj-$(CONFIG_RESET_SYSCON) += reset-syscon.o
 obj-$(CONFIG_RESET_RASPBERRYPI) += reset-raspberrypi.o
 obj-$(CONFIG_RESET_SCMI) += reset-scmi.o
 obj-$(CONFIG_RESET_DISPMIX) += reset-dispmix.o
+obj-$(CONFIG_RESET_IMX_HDMIMIX) += reset-imx-hdmimix.o
diff --git a/drivers/reset/reset-imx-hdmimix.c b/drivers/reset/reset-imx-hdmimix.c
new file mode 100644
index 0000000000..b288de3405
--- /dev/null
+++ b/drivers/reset/reset-imx-hdmimix.c
@@ -0,0 +1,139 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2020 NXP
+ *
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <dt-bindings/reset/imx-hdmimix-reset.h>
+#include <linux/io.h>
+#include <reset.h>
+#include <reset-uclass.h>
+
+#define IMX_HDMIMIX_RESET_CTL0_REG	0x20
+#define IMX_HDMIMIX_RESET_CTL0_REG_SET	0x24
+#define IMX_HDMIMIX_RESET_CTL0_REG_CLR	0x28
+
+#define IMX_HDMIMIX_RESET_CTL0_TX_TRNG_RESETN							(1 << 20)
+#define IMX_HDMIMIX_RESET_CTL0_VID_LINK_SLV_RESETN						(1 << 22)
+#define IMX_HDMIMIX_RESET_CTL0_PAI_RESETN								(1 << 18)
+#define IMX_HDMIMIX_RESET_CTL0_IRQ_STEER_RESETN							(1 << 16)
+#define IMX_HDMIMIX_RESET_CTL0_TX_KSV_MEM_RESETN						(1 << 13)
+#define IMX_HDMIMIX_RESET_CTL0_TX_PHY_PRESETN							(1 << 12)
+#define IMX_HDMIMIX_RESET_CTL0_TX_APBRSTZ								(1 << 11)
+#define IMX_HDMIMIX_RESET_CTL0_TX_RSTZ									(1 << 10)
+#define IMX_HDMIMIX_RESET_CTL0_FDCC_HDMI_RESETN							(1 << 7)
+#define IMX_HDMIMIX_RESET_CTL0_FDCC_RESETN								(1 << 6)
+#define IMX_HDMIMIX_RESET_CTL0_LCDIF_APB_RESETN							(1 << 5)
+#define IMX_HDMIMIX_RESET_CTL0_LCDIF_ASYNC_RESETN						(1 << 4)
+#define IMX_HDMIMIX_RESET_CTL0_NOC_RESETN								(1 << 0)
+
+struct imx_hdmimix_reset_data {
+	void __iomem *base;
+};
+
+static int imx_hdmimix_reset_set(struct reset_ctl *rst, bool assert)
+{
+	struct imx_hdmimix_reset_data *drvdata =
+		(struct imx_hdmimix_reset_data *)dev_get_priv(rst->dev);
+
+	void __iomem *reg_addr = drvdata->base;
+	unsigned int val;
+	unsigned long id = rst->id;
+
+	switch (id) {
+	case IMX_HDMIMIX_HDMI_TX_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_TX_APBRSTZ |
+				IMX_HDMIMIX_RESET_CTL0_TX_RSTZ |
+				IMX_HDMIMIX_RESET_CTL0_FDCC_HDMI_RESETN |
+				IMX_HDMIMIX_RESET_CTL0_FDCC_RESETN;
+		break;
+	case IMX_HDMIMIX_HDMI_PHY_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_TX_PHY_PRESETN;
+		break;
+	case IMX_HDMIMIX_HDMI_PAI_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_PAI_RESETN;
+		break;
+	case IMX_HDMIMIX_HDMI_PVI_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_VID_LINK_SLV_RESETN;
+		break;
+	case IMX_HDMIMIX_HDMI_TRNG_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_TX_TRNG_RESETN;
+		break;
+	case IMX_HDMIMIX_IRQ_STEER_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_IRQ_STEER_RESETN;
+		break;
+	case IMX_HDMIMIX_HDMI_HDCP_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_TX_KSV_MEM_RESETN;
+		break;
+	case IMX_HDMIMIX_LCDIF_RESET:
+		val = IMX_HDMIMIX_RESET_CTL0_LCDIF_APB_RESETN |
+				IMX_HDMIMIX_RESET_CTL0_LCDIF_ASYNC_RESETN;
+		break;
+	default:
+		return -EINVAL;
+	}
+	debug("%s: %s id=%ld, val=%x, %p\n", __func__,
+		assert ? "assert" : "release", id, val, reg_addr +
+		(assert ? IMX_HDMIMIX_RESET_CTL0_REG_CLR :
+			IMX_HDMIMIX_RESET_CTL0_REG_SET));
+#if 0
+	if (assert) {
+		writel(val, reg_addr + IMX_HDMIMIX_RESET_CTL0_REG_CLR);
+	} else {
+		writel(val, reg_addr + IMX_HDMIMIX_RESET_CTL0_REG_SET);
+	}
+#endif
+	return 0;
+}
+
+static int imx_hdmimix_reset_assert(struct reset_ctl *rst)
+{
+	return imx_hdmimix_reset_set(rst, true);
+}
+
+static int imx_hdmimix_reset_deassert(struct reset_ctl *rst)
+{
+	return imx_hdmimix_reset_set(rst, false);
+}
+
+static int imx_hdmimix_reset_free(struct reset_ctl *rst)
+{
+	return 0;
+}
+
+static int imx_hdmimix_reset_request(struct reset_ctl *rst)
+{
+	return 0;
+}
+
+static const struct reset_ops imx_hdmimix_reset_ops = {
+	.request = imx_hdmimix_reset_request,
+	.rfree = imx_hdmimix_reset_free,
+	.rst_assert   = imx_hdmimix_reset_assert,
+	.rst_deassert = imx_hdmimix_reset_deassert,
+};
+
+static int imx_hdmimix_reset_probe(struct udevice *dev)
+{
+	struct imx_hdmimix_reset_data *drvdata = (struct imx_hdmimix_reset_data *)dev_get_priv(dev);
+
+	drvdata->base = (void *)dev_read_addr(dev);
+	return 0;
+}
+
+static const struct udevice_id imx_hdmimix_reset_dt_ids[] = {
+	{ .compatible = "fsl,imx8mp-hdmimix-reset", },
+	{ /* sentinel */ },
+};
+
+U_BOOT_DRIVER(imx_hdmimix_reset) = {
+	.name = "imx_hdmimix_reset",
+	.id = UCLASS_RESET,
+	.of_match = imx_hdmimix_reset_dt_ids,
+	.ops = &imx_hdmimix_reset_ops,
+	.probe = imx_hdmimix_reset_probe,
+	.priv_auto = sizeof(struct imx_hdmimix_reset_data),
+};
diff --git a/drivers/reset/reset-uclass.c b/drivers/reset/reset-uclass.c
index 8d14a6021b..5a0d2bfc23 100644
--- a/drivers/reset/reset-uclass.c
+++ b/drivers/reset/reset-uclass.c
@@ -3,6 +3,8 @@
  * Copyright (c) 2016, NVIDIA CORPORATION.
  */
 
+#define LOG_CATEGORY UCLASS_RESET
+
 #include <common.h>
 #include <dm.h>
 #include <fdtdec.h>
@@ -24,7 +26,7 @@ static int reset_of_xlate_default(struct reset_ctl *reset_ctl,
 	debug("%s(reset_ctl=%p)\n", __func__, reset_ctl);
 
 	if (args->args_count != 1) {
-		debug("Invaild args_count: %d\n", args->args_count);
+		debug("Invalid args_count: %d\n", args->args_count);
 		return -EINVAL;
 	}
 
@@ -95,7 +97,7 @@ int reset_get_by_index_nodev(ofnode node, int index,
 	int ret;
 
 	ret = ofnode_parse_phandle_with_args(node, "resets", "#reset-cells", 0,
-					     index > 0, &args);
+					     index, &args);
 
 	return reset_get_by_index_tail(ret, node, &args, "resets",
 				       index > 0, reset_ctl);
@@ -359,6 +361,8 @@ struct reset_ctl_bulk *devm_reset_bulk_get_by_node(struct udevice *dev,
 	bulk = devres_alloc(devm_reset_bulk_release,
 			    sizeof(struct reset_ctl_bulk),
 			    __GFP_ZERO);
+
+	/* this looks like a leak, but devres takes care of it */
 	if (unlikely(!bulk))
 		return ERR_PTR(-ENOMEM);
 
@@ -393,6 +397,25 @@ struct reset_ctl_bulk *devm_reset_bulk_get_optional(struct udevice *dev)
 	return devm_reset_bulk_get_optional_by_node(dev, dev_ofnode(dev));
 }
 
+int device_reset(struct udevice *dev)
+{
+	int ret = 0;
+	struct reset_ctl_bulk bulk;
+
+	ret = reset_get_bulk(dev, &bulk);
+	if (ret) {
+		debug("%s: reset_get_bulk %d\n", __func__, ret);
+		return ret;
+	}
+	ret = reset_assert_bulk(&bulk);
+	if (ret)
+		debug("%s: reset_assert_bulk %d\n", __func__, ret);
+	ret = reset_deassert_bulk(&bulk);
+	if (ret)
+		debug("%s: reset_deassert_bulk %d\n", __func__, ret);
+	return ret;
+}
+
 UCLASS_DRIVER(reset) = {
 	.id		= UCLASS_RESET,
 	.name		= "reset",
diff --git a/drivers/video/nxp/imx/Kconfig b/drivers/video/nxp/imx/Kconfig
index c02014826f..eb6d32d907 100644
--- a/drivers/video/nxp/imx/Kconfig
+++ b/drivers/video/nxp/imx/Kconfig
@@ -23,6 +23,15 @@ config VIDEO_IMX8_LVDS
 	help
 	  Support for i.MX8 LDVS bridge controller for i.MX8 processors.
 
+config VIDEO_IMX8MP_LVDS
+	bool "i.MX8MP LDVS bridge support"
+	default n
+	depends on IMX8MP && DM_VIDEO
+	select DISPLAY
+	select VIDEO_LINK
+	help
+	  Support for i.MX8MP LDVS bridge controller for i.MX8 processors.
+
 config VIDEO_IMX_HDP_LOAD
 	bool "i.MX8 HDMI/DP firmware loading"
 	default n
diff --git a/drivers/video/nxp/imx/Makefile b/drivers/video/nxp/imx/Makefile
index b9e1695a65..31a7ab4c84 100644
--- a/drivers/video/nxp/imx/Makefile
+++ b/drivers/video/nxp/imx/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_VIDEO_IMX8M_DCSS) += imx8m_dcss.o
 obj-$(CONFIG_VIDEO_SEC_MIPI_DSI) += sec_mipi_dsim.o
 obj-$(CONFIG_VIDEO_IMX_SEC_DSI) += sec_dsim_imx.o
 obj-$(CONFIG_VIDEO_IMX_LCDIFV3) += imx_lcdifv3.o
+obj-$(CONFIG_VIDEO_IMX8MP_LVDS) += imx8mp_lvds.o
 obj-$(CONFIG_VIDEO_NW_MIPI_DSI) += mipi_dsi_northwest.o
 obj-$(CONFIG_VIDEO_IMX_NW_DSI) += nw_dsi_imx.o
 obj-y += hdmi/
diff --git a/drivers/video/nxp/imx/imx8mp_lvds.c b/drivers/video/nxp/imx/imx8mp_lvds.c
new file mode 100644
index 0000000000..099263e2bc
--- /dev/null
+++ b/drivers/video/nxp/imx/imx8mp_lvds.c
@@ -0,0 +1,281 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2022 NXP
+ */
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <dm/device_compat.h>
+#include <display.h>
+#include <video.h>
+#include <video_bridge.h>
+#include <video_link.h>
+#include <asm/io.h>
+#include <dm/device-internal.h>
+#include <linux/iopoll.h>
+#include <linux/err.h>
+#include <clk.h>
+
+#include <power-domain.h>
+#include <regmap.h>
+#include <syscon.h>
+
+#define DRIVER_NAME "imx8mp-ldb"
+
+
+#define LVDS_CTRL		0x128
+#define HS_DISABLE		(0 << 3)
+#define SPARE_IN(n)		(((n) & 0x7) << 25)
+#define SPARE_IN_MASK		0xe000000
+#define TEST_RANDOM_NUM_EN	BIT(24)
+#define TEST_MUX_SRC(n)		(((n) & 0x3) << 22)
+#define TEST_MUX_SRC_MASK	0xc00000
+#define TEST_EN			BIT(21)
+#define TEST_DIV4_EN		BIT(20)
+#define VBG_ADJ(n)		(((n) & 0x7) << 17)
+#define VBG_ADJ_MASK		0xe0000
+#define SLEW_ADJ(n)		(((n) & 0x7) << 14)
+#define SLEW_ADJ_MASK		0x1c000
+#define CC_ADJ(n)		(((n) & 0x7) << 11)
+#define CC_ADJ_MASK		0x3800
+#define CM_ADJ(n)		(((n) & 0x7) << 8)
+#define CM_ADJ_MASK		0x700
+#define PRE_EMPH_ADJ(n)		(((n) & 0x7) << 5)
+#define PRE_EMPH_ADJ_MASK	0xe0
+#define PRE_EMPH_EN		BIT(4)
+#define HS_EN			BIT(3)
+#define BG_EN			BIT(2)
+#define CH_EN		    BIT(0)
+
+
+#define LDB_CTRL		0x5c
+#define LDB_CH0_MODE_EN_TO_DI0		(1 << 0)
+#define LDB_CH0_MODE_EN_TO_DI1		(3 << 0)
+#define LDB_CH0_MODE_EN_MASK		(3 << 0)
+#define LDB_CH1_MODE_EN_TO_DI0		(1 << 2)
+#define LDB_CH1_MODE_EN_TO_DI1		(3 << 2)
+#define LDB_CH1_MODE_EN_MASK		(3 << 2)
+#define CH0_DATA_WIDTH_24BIT		(1 << 5)
+#define CH0_BIT_MAPPING_JEIDA		(1 << 6)
+#define CH0_BIT_MAPPING_SPWG		(0 << 6)
+#define LDB_REG_CH0_FIFO_RESET		(1 << 11)
+#define LDB_REG_CH1_FIFO_RESET		(1 << 12)
+#define LDB_REG_ASYNC_FIFO_EN		(1 << 24)
+#define LDB_FIFO_THRESHOLD		(4 << 25)
+
+#define CLK_EN 0x4
+
+#define usleep_range(a, b) udelay((b))
+
+#define serial_clk 74250*7000
+
+struct imx8mp_ldb_priv {
+	struct regmap *regmap;
+	struct udevice *conn_dev;
+	unsigned int ldb_id;
+	struct clk *ldb_root_clk;
+	struct clk *apb_root_clk;
+	struct display_timing timings;
+};
+
+
+static inline unsigned int media_blk_read(struct imx8mp_ldb_priv *priv, unsigned int reg)
+{
+	unsigned int val;
+
+	regmap_read(priv->regmap, reg, &val);
+
+	return val;
+}
+
+static inline void media_blk_write(struct imx8mp_ldb_priv *priv, unsigned int reg, unsigned int value)
+{
+	regmap_write(priv->regmap, reg, value);
+}
+
+static int imx8mp_lvds_phy_power_on(struct udevice *dev)
+{
+	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
+	
+	unsigned int val;
+	u32 ldb_ctrl;
+	bool bg_en;
+
+ 	media_blk_write(priv, LVDS_CTRL, HS_DISABLE);
+
+	val = media_blk_read(priv,LVDS_CTRL);
+	bg_en = !!(val & BG_EN);
+	val |= BG_EN;
+	media_blk_write(priv, LVDS_CTRL, val);
+
+	if (!bg_en){
+		usleep_range(15, 20);
+	}
+		
+	val = media_blk_read(priv, LVDS_CTRL);
+	val |= CH_EN;
+	val |= BIT(3);
+	media_blk_write(priv, LVDS_CTRL, val);
+
+#ifdef CONFIG_TARGET_UCM_IMX8M_PLUS
+	media_blk_write(priv, LDB_CTRL, LDB_CH0_MODE_EN_TO_DI0 | CH0_DATA_WIDTH_24BIT);
+#else
+	media_blk_write(priv, LDB_CTRL, LDB_CH0_MODE_EN_TO_DI0 | CH0_DATA_WIDTH_24BIT | CH0_BIT_MAPPING_JEIDA);
+#endif
+ 
+	usleep_range(5, 10);
+	
+	return 0;
+
+}
+
+int imx8mp_ldb_read_timing(struct udevice *dev, struct display_timing *timing)
+{
+	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
+
+	if (dev->plat_ == NULL)
+		return -EINVAL;
+
+	if (timing) {
+		memcpy(timing, &priv->timings, sizeof(struct display_timing));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int imx8mp_ldb_probe(struct udevice *dev)
+{
+	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	debug("%s\n", __func__);
+
+	if (dev->plat_ == NULL) {
+		priv->regmap = syscon_regmap_lookup_by_phandle(dev, "gpr");
+		if (IS_ERR(priv->regmap)) {
+			debug("fail to get fsl,imx8mp-mediamix-blk-ctl regmap\n");
+			return PTR_ERR(priv->regmap);
+		}
+
+		/* Require to add alias in DTB */
+		priv->ldb_id = dev_seq(dev);
+
+		debug("ldb_id %u\n", priv->ldb_id);
+	}else{
+		
+		priv->conn_dev = video_link_get_next_device(dev);
+		if (!priv->conn_dev) {
+			debug("can't find next device in video link\n");
+		}
+
+		ret = video_link_get_display_timings(&priv->timings);
+		if (ret) {
+			debug("decode display timing error %d\n", ret);
+			return ret;
+		}
+		
+		if(priv->conn_dev && device_get_uclass_id(priv->conn_dev) == UCLASS_PANEL){
+			ret = panel_enable_backlight(priv->conn_dev);
+			if (ret) {
+					dev_err(dev, "fail to enable panel backlight\n");
+					return ret;
+			}
+			ret = panel_set_backlight(priv->conn_dev, 80);
+				if (ret) {
+					dev_err(dev, "fail to set panel backlight\n");
+					return ret;
+			}
+		}
+
+		if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
+			if (priv->conn_dev &&
+				device_get_uclass_id(priv->conn_dev) == UCLASS_VIDEO_BRIDGE) {
+
+				ret = video_bridge_attach(priv->conn_dev);
+				if (ret) {
+					dev_err(dev, "fail to attach bridge\n");
+					return ret;
+				}
+				ret = video_bridge_set_active(priv->conn_dev, true);
+				if (ret) {
+					dev_err(dev, "fail to active bridge\n");
+					return ret;
+				}
+			}
+		}
+	}
+    printf("imx8mp_ldb_probe\n");
+
+	return 0;
+
+}
+
+static int imx8mp_ldb_bind(struct udevice *dev)
+{
+	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
+	ofnode lvds_ch_node;
+	int ret = 0;
+
+	debug("%s\n", __func__);
+	lvds_ch_node = ofnode_find_subnode(dev_ofnode(dev), "lvds-channel@0");
+	if (ofnode_valid(lvds_ch_node)) {
+		ret = device_bind(dev, dev->driver, "lvds-channel@0", (void *)1,
+			lvds_ch_node, NULL);
+		if (ret)
+			debug("Error binding driver '%s': %d\n", dev->driver->name,
+				ret);
+	}
+
+	return ret;
+}
+
+
+int imx8mp_ldb_enable(struct udevice *dev, int panel_bpp,
+		      const struct display_timing *timing)
+{
+	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
+	int ret;
+	debug("%s\n", __func__);
+
+	if (dev->plat_ == NULL) {
+
+		imx8mp_lvds_phy_power_on(dev);
+	} else {
+		display_enable(dev->parent, panel_bpp, &priv->timings);
+
+		if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
+			if (priv->conn_dev &&
+				device_get_uclass_id(priv->conn_dev) == UCLASS_VIDEO_BRIDGE) {
+				ret = video_bridge_set_backlight(priv->conn_dev, 80);
+				if (ret) {
+					dev_err(dev, "fail to set backlight\n");
+					return ret;
+				}
+			}
+		}
+	}
+
+	return 0;
+
+}
+
+struct dm_display_ops imx8mp_ldb_ops = {
+	.read_timing = imx8mp_ldb_read_timing,
+	.enable = imx8mp_ldb_enable,
+};
+
+static const struct udevice_id imx8mp_ldb_ids[] = {
+	{ .compatible = "fsl,imx8mp-ldb" },
+	{ }
+};
+
+U_BOOT_DRIVER(imx8mp_ldb) = {
+	.name				= "imx8mp_ldb",
+	.id				= UCLASS_DISPLAY,
+	.of_match			= imx8mp_ldb_ids,
+	.bind				= imx8mp_ldb_bind,
+	.probe				= imx8mp_ldb_probe,
+	.ops				= &imx8mp_ldb_ops,
+	.priv_auto		= sizeof(struct imx8mp_ldb_priv),
+};
diff --git a/drivers/video/nxp/imx/imx_lcdifv3.c b/drivers/video/nxp/imx/imx_lcdifv3.c
index 1eb9938777..bccee3fbb7 100644
--- a/drivers/video/nxp/imx/imx_lcdifv3.c
+++ b/drivers/video/nxp/imx/imx_lcdifv3.c
@@ -4,6 +4,7 @@
  */
 
 #include <common.h>
+#include <clk.h>
 #include <malloc.h>
 #include <video.h>
 #include <video_fb.h>
@@ -32,6 +33,14 @@
 #define	PS2KHZ(ps)	(1000000000UL / (ps))
 #define HZ2PS(hz)	(1000000000UL / ((hz) / 1000))
 
+struct lcdifv3_soc_pdata {
+	bool hsync_invert;
+	bool vsync_invert;
+	bool de_invert;
+	bool hdmimix;
+	bool hvsync_high;	/* mipi needs it high */
+};
+
 struct lcdifv3_priv {
 	fdt_addr_t reg_base;
 	struct udevice *disp_dev;
@@ -40,6 +49,9 @@ struct lcdifv3_priv {
 	u32 thres_low_div;
 	u32 thres_high_mul;
 	u32 thres_high_div;
+
+	struct clk lcdif_pix;
+	struct clk *mix_clks;
 };
 
 static int lcdifv3_set_pix_fmt(struct lcdifv3_priv *priv, unsigned int format)
@@ -60,7 +72,7 @@ static int lcdifv3_set_pix_fmt(struct lcdifv3_priv *priv, unsigned int format)
 		ctrldescl0_5 |= CTRLDESCL0_5_BPP(BPP32_ARGB8888);
 		break;
 	default:
-		printf("unsupported pixel format: %u\n", format);
+		debug("unsupported pixel format: %u\n", format);
 		return -EINVAL;
 	}
 
@@ -199,6 +211,13 @@ static void lcdifv3_init(struct udevice *dev,
 	struct lcdifv3_priv *priv = dev_get_priv(dev);
 	int ret;
 
+	debug("%s %d dev/priv %p/%p\n",__func__,__LINE__,dev,priv);
+
+	if (priv==NULL)
+		return;
+
+	debug("%s %d %p\n",__func__,__LINE__,priv);
+
 	/* Kick in the LCDIF clock */
 	mxs_set_lcdclk(priv->reg_base, PS2KHZ(mode->pixclock));
 
@@ -213,7 +232,7 @@ static void lcdifv3_init(struct udevice *dev,
 
 	ret = lcdifv3_set_pix_fmt(priv, format);
 	if (ret) {
-		printf("Fail to init lcdifv3, wrong format %u\n", format);
+		debug("Fail to init lcdifv3, wrong format %u\n", format);
 		return;
 	}
 
@@ -252,9 +271,10 @@ static int lcdifv3_of_get_timings(struct udevice *dev,
 	priv->disp_dev = video_link_get_next_device(dev);
 	if (!priv->disp_dev ||
 		(device_get_uclass_id(priv->disp_dev) != UCLASS_VIDEO_BRIDGE
-		&& device_get_uclass_id(priv->disp_dev) != UCLASS_DISPLAY)) {
+		&& device_get_uclass_id(priv->disp_dev) != UCLASS_DISPLAY
+		&& device_get_uclass_id(priv->disp_dev) != UCLASS_PANEL)) {
 
-		printf("fail to find output device\n");
+		debug("fail to find output device\n");
 		return -ENODEV;
 	}
 
@@ -262,7 +282,7 @@ static int lcdifv3_of_get_timings(struct udevice *dev,
 
 	ret = video_link_get_display_timings(timings);
 	if (ret) {
-		printf("fail to get display timings\n");
+		debug("fail to get display timings\n");
 		return ret;
 	}
 
@@ -317,6 +337,89 @@ static void lcdifv3_of_parse_thres(struct udevice *dev)
 }
 
 
+u32 pll_rates[] = {
+	 361267200U,
+	 364000000U,
+	 384000000U,
+	 393216000U,
+	 452900000U,
+	 453000000U,
+	 497755966U,
+	 519750000U,
+	 594000000U,
+	 650000000U,
+	1039500000U,
+};
+
+static u32 get_pixclock(struct clk *pll, unsigned long pixclock, int ldb)
+{
+	unsigned long rate;
+	unsigned long best = 0, best_n = 1, best_diff = ~0;
+	unsigned long cur, cur_n, cur_diff;
+	int i;
+	int ret;
+
+
+	for (i = 0; i < ARRAY_SIZE(pll_rates); i++) {
+		rate = pll_rates[i];
+		if (!ldb)
+			cur_n = (rate + (pixclock >> 1)) / pixclock;
+		else
+			cur_n = 7;
+		cur = rate / cur_n;
+		if (cur >= pixclock)
+			cur_diff = cur - pixclock;
+		else
+			cur_diff = pixclock - cur;
+		if (best_diff > cur_diff) {
+			best_diff = cur_diff;
+			best = cur;
+			best_n = cur_n;
+		}
+		if (!cur_diff)
+			break;
+	}
+	cur = best * best_n;
+	debug("%s: %ld = %ld * %ld\n", __func__, cur, best, best_n);
+	ret = clk_set_rate(pll, cur);
+	if (ret < 0) {
+		debug("clk_set_rate %ld failed(%d)\n", cur, ret);
+		cur = clk_get_rate(pll);
+		debug("rate is %ld\n", cur);
+	}
+	best_n = (cur + (pixclock >> 1)) / pixclock;
+	pixclock = cur / best_n;
+	debug("%s: pixclock = %ld\n", __func__, pixclock);
+	return pixclock;
+}
+const char* const mix_clocks[] = {
+	"mix_apb",
+	"mix_axi",
+	"xtl_24m",
+	"mix_pix",
+	"lcdif_apb",
+	"lcdif_axi",
+	"lcdif_pdi",
+	"lcdif_pix",
+	"lcdif_spu",
+	"noc_hdmi",
+};
+
+static int hdmimix_lcdif3_setup(struct lcdifv3_priv *priv, struct udevice *dev)
+{
+	int ret;
+
+	debug("%s:\n", __func__);
+	device_reset(dev);
+	/* enable lpcg of hdmimix lcdif and nor */
+	ret = devm_clk_get_enable_bulk(dev, mix_clocks, ARRAY_SIZE(mix_clocks), 0, &priv->mix_clks);
+	if (ret) {
+		debug("%s: ret=%d\n", __func__, ret);
+		return ret;
+	}
+	return 0;
+}
+
 static int lcdifv3_video_probe(struct udevice *dev)
 {
 	struct video_uc_plat *plat = dev_get_uclass_plat(dev);
@@ -329,6 +432,8 @@ static int lcdifv3_video_probe(struct udevice *dev)
 	u32 fb_start, fb_end;
 	int ret;
 
+	struct lcdifv3_soc_pdata *pdata = (struct lcdifv3_soc_pdata *)dev_get_driver_data(dev);
+
 	debug("%s() plat: base 0x%lx, size 0x%x\n",
 	       __func__, plat->base, plat->size);
 
@@ -342,10 +447,48 @@ static int lcdifv3_video_probe(struct udevice *dev)
 	if (ret)
 		return ret;
 
+#if CONFIG_IS_ENABLED(CLK)
+{
+	struct clk* video_pll;
+	struct clk* clk_ldb;
+	u32 pixclock;
+	clk_ldb = devm_clk_get_optional(dev, "ldb");
+	if (IS_ERR(clk_ldb))
+		return PTR_ERR(clk_ldb);
+
+	video_pll = devm_clk_get_optional(dev, "video_pll");
+	if (IS_ERR(video_pll))
+		return PTR_ERR(video_pll);
+
+	if (video_pll) {
+		pixclock = get_pixclock(video_pll, timings.pixelclock.typ, clk_ldb ? 1 : 0);
+	} else {
+		pixclock = timings.pixelclock.typ;
+	}
+	ret = clk_get_by_name(dev, "pix", &priv->lcdif_pix);
+	if (ret) {
+		debug("Failed to get pix clk\n");
+		return ret;
+	}
+
+	if (clk_ldb) {
+		ret = clk_set_rate(video_pll, pixclock * 7);
+		if (ret < 0) {
+			debug("Failed to set pll rate(%d) %d\n", pixclock, ret);
+			return ret;
+		}
+	}
+
+	ret = clk_set_rate(&priv->lcdif_pix, pixclock);
+	if (ret < 0) {
+		debug("Failed to set pix clk rate(%d) %d\n", pixclock, ret);
+		return ret;
+	}
+}
+#endif
 	lcdifv3_of_parse_thres(dev);
 
 	if (priv->disp_dev) {
-#if IS_ENABLED(CONFIG_VIDEO_BRIDGE)
 		if (device_get_uclass_id(priv->disp_dev) == UCLASS_VIDEO_BRIDGE) {
 			ret = video_bridge_attach(priv->disp_dev);
 			if (ret) {
@@ -358,8 +501,31 @@ static int lcdifv3_video_probe(struct udevice *dev)
 				dev_err(dev, "fail to set backlight\n");
 				return ret;
 			}
+		} else {
+			ret = display_enable(priv->disp_dev, NULL, NULL);
+			if (ret) {
+				return ret;
+			}
+		}
+	}
+
+	if (pdata->hvsync_high) {
+		/* mipi needs high */
+		timings.flags |= (DISPLAY_FLAGS_HSYNC_HIGH | DISPLAY_FLAGS_VSYNC_HIGH);
+		timings.flags &= ~(DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW);
+	}
+	if (pdata->hsync_invert)
+		timings.flags ^= (DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_HSYNC_HIGH);
+	if (pdata->vsync_invert)
+		timings.flags ^= (DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_VSYNC_HIGH);
+	if (pdata->de_invert)
+		timings.flags ^= (DISPLAY_FLAGS_DE_LOW | DISPLAY_FLAGS_DE_HIGH);
+	if (pdata->hdmimix) {
+		ret = hdmimix_lcdif3_setup(priv, dev);
+		if (ret < 0) {
+			debug("hdmimix lcdif3 setup failed\n");
+			return ret;
 		}
-#endif
 	}
 
 	mode.xres = timings.hactive.typ;
@@ -414,8 +580,32 @@ static int lcdifv3_video_remove(struct udevice *dev)
 	return 0;
 }
 
+static const struct lcdifv3_soc_pdata imx8mp_lcdif1_pdata = {
+	.hsync_invert = false,
+	.vsync_invert = false,
+	.de_invert    = false,
+	.hdmimix     = false,
+	.hvsync_high = true,
+};
+
+static const struct lcdifv3_soc_pdata imx8mp_lcdif2_pdata = {
+	.hsync_invert = false,
+	.vsync_invert = false,
+	.de_invert    = true,
+	.hdmimix      = false,
+};
+
+static const struct lcdifv3_soc_pdata imx8mp_lcdif3_pdata = {
+	.hsync_invert = false,
+	.vsync_invert = false,
+	.de_invert    = false,
+	.hdmimix     = true,
+};
+
 static const struct udevice_id lcdifv3_video_ids[] = {
-	{ .compatible = "fsl,imx8mp-lcdif1" },
+	{ .compatible = "fsl,imx8mp-lcdif1", .data = (ulong)&imx8mp_lcdif1_pdata,},
+	{ .compatible = "fsl,imx8mp-lcdif2", .data = (ulong)&imx8mp_lcdif2_pdata,},
+	{ .compatible = "fsl,imx8mp-lcdif3", .data = (ulong)&imx8mp_lcdif3_pdata,},
 	{ /* sentinel */ }
 };
 
diff --git a/include/dt-bindings/clock/imx8mp-clock1.h b/include/dt-bindings/clock/imx8mp-clock1.h
new file mode 100644
index 0000000000..e35234148a
--- /dev/null
+++ b/include/dt-bindings/clock/imx8mp-clock1.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 NXP
+ */
+
+#ifndef __DT_BINDINGS_CLOCK1_IMX8MP_H
+#define __DT_BINDINGS_CLOCK1_IMX8MP_H
+
+/* HDMIMIX CLK */
+#define IMX8MP_CLK_HDMIMIX_GLOBAL_APB_CLK		0
+#define IMX8MP_CLK_HDMIMIX_GLOBAL_B_CLK			1
+#define IMX8MP_CLK_HDMIMIX_GLOBAL_REF266M_CLK	2
+#define IMX8MP_CLK_HDMIMIX_GLOBAL_XTAL24M_CLK	3
+#define IMX8MP_CLK_HDMIMIX_GLOBAL_XTAL32K_CLK	4
+#define IMX8MP_CLK_HDMIMIX_GLOBAL_TX_PIX_CLK	5
+#define IMX8MP_CLK_HDMIMIX_IRQS_STEER_CLK		6
+#define IMX8MP_CLK_HDMIMIX_NOC_HDMI_CLK			7
+#define IMX8MP_CLK_HDMIMIX_NOC_HDCP_CLK			8
+#define IMX8MP_CLK_HDMIMIX_LCDIF_APB_CLK		9
+#define IMX8MP_CLK_HDMIMIX_LCDIF_B_CLK			10
+#define IMX8MP_CLK_HDMIMIX_LCDIF_PDI_CLK		11
+#define IMX8MP_CLK_HDMIMIX_LCDIF_PIX_CLK		12
+#define IMX8MP_CLK_HDMIMIX_LCDIF_SPU_CLK		13
+#define IMX8MP_CLK_HDMIMIX_FDCC_REF_CLK			14
+#define IMX8MP_CLK_HDMIMIX_HRV_MWR_APB_CLK		15
+#define IMX8MP_CLK_HDMIMIX_HRV_MWR_B_CLK		16
+#define IMX8MP_CLK_HDMIMIX_HRV_MWR_CEA_CLK		17
+#define IMX8MP_CLK_HDMIMIX_VSFD_CEA_CLK			18
+#define IMX8MP_CLK_HDMIMIX_TX_HPI_CLK			19
+#define IMX8MP_CLK_HDMIMIX_TX_APB_CLK			20
+#define IMX8MP_CLK_HDMIMIX_TX_CEC_CLK			21
+#define IMX8MP_CLK_HDMIMIX_TX_ESM_CLK			22
+#define IMX8MP_CLK_HDMIMIX_TX_GPA_CLK			23
+#define IMX8MP_CLK_HDMIMIX_TX_PIXEL_CLK			24
+#define IMX8MP_CLK_HDMIMIX_TX_SFR_CLK			25
+#define IMX8MP_CLK_HDMIMIX_TX_SKP_CLK			26
+#define IMX8MP_CLK_HDMIMIX_TX_PREP_CLK			27
+#define IMX8MP_CLK_HDMIMIX_TX_PHY_APB_CLK		28
+#define IMX8MP_CLK_HDMIMIX_TX_PHY_INT_CLK		29
+#define IMX8MP_CLK_HDMIMIX_TX_SEC_MEM_CLK		30
+#define IMX8MP_CLK_HDMIMIX_TX_TRNG_SKP_CLK		31
+#define IMX8MP_CLK_HDMIMIX_TX_VID_LINK_PIX_CLK	32
+#define IMX8MP_CLK_HDMIMIX_TX_TRNG_APB_CLK		33
+#define IMX8MP_CLK_HDMIMIX_HTXPHY_CLK_SEL		34
+#define IMX8MP_CLK_HDMIMIX_LCDIF_CLK_SEL		35
+#define IMX8MP_CLK_HDMIMIX_TX_PIPE_CLK_SEL		36
+
+#define IMX8MP_CLK_HDMIMIX_END					37
+
+#endif
diff --git a/include/dt-bindings/reset/imx-hdmimix-reset.h b/include/dt-bindings/reset/imx-hdmimix-reset.h
new file mode 100644
index 0000000000..6a6f726a09
--- /dev/null
+++ b/include/dt-bindings/reset/imx-hdmimix-reset.h
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2020 NXP.
+ */
+
+#ifndef DT_BINDING_RESET_IMX_HDMIMIX_H
+#define DT_BINDING_RESET_IMX_HDMIMIX_H
+
+#define IMX_HDMIMIX_HDMI_TX_RESET		0x0
+#define IMX_HDMIMIX_HDMI_PHY_RESET		0x1
+#define IMX_HDMIMIX_HDMI_PAI_RESET		0x2
+#define IMX_HDMIMIX_HDMI_PVI_RESET		0x3
+#define IMX_HDMIMIX_HDMI_TRNG_RESET		0x4
+#define IMX_HDMIMIX_IRQ_STEER_RESET		0x5
+#define IMX_HDMIMIX_HDMI_HDCP_RESET		0x6
+#define IMX_HDMIMIX_LCDIF_RESET			0x7
+
+#define IMX_HDMIMIX_RESET_NUM		8
+
+#endif
+
-- 
2.17.1

